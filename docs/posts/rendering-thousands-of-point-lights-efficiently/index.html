<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="TL;DR;
In this post, I&rsquo;ll explain a rendering technique called Clustered Rendering, which I used in my game engine to efficiently render (possibly) thousands of point lights. Clustered Rendering is compatible with both Forward and Deferred rendering architectures. When combined with Forward rendering, it&rsquo;s often referred to as Forward&#43;.

Table Of Contents

Preface
How Clustered Rendering Works
Implementation

Bin Mapping
Tile Mapping
Lighting Computation in the Shader
Code


Resources

Preface
When doing real-time rendering for games, especially 3D games, we usually want to light the scene dynamically. Games commonly use three types of lights: Directional Lights, Point Lights, and Spot Lights.">  

  <title>
    
      Rendering Thousands of Point Lights Efficiently
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="/css/main.c986fb33d5ffdb527f52261aa566f8b59ed81c849c1f0ca7be5ab221a5d71831986b03eb5446012d28b07534e698d558db9cc84eb5d0ad5d5aa2e4ebf1cec969.css" integrity="sha512-yYb7M9X/21J/UiYapWb4tZ7YHIScHwynvlqyIaXXGDGYawPrVEYBLSiwdTTmmNVY25zITrXQrV1aouTr8c7JaQ==" />
  
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
<a href="/">..</a>


<article>
    <p class="post-meta">
        <time datetime="2025-03-10 10:00:00 &#43;0200 &#43;0200">
            2025-03-10
        </time>
    </p>

    <h1>Rendering Thousands of Point Lights Efficiently</h1>

    

    <h2 id="tldr">TL;DR;</h2>
<p>In this post, I&rsquo;ll explain a rendering technique called Clustered Rendering, which I used in <a href="https://flexw.github.io/posts/learnings-from-creating-a-game-engine/">my game engine</a> to efficiently render (possibly) thousands of point lights. Clustered Rendering is compatible with both Forward and Deferred rendering architectures. When combined with Forward rendering, it&rsquo;s often referred to as Forward+.</p>
<p><img src="images/shooting.png" alt="Game"></p>
<h2 id="table-of-contents">Table Of Contents</h2>
<ul>
<li><a href="#preface">Preface</a></li>
<li><a href="#how-clustered-rendering-works">How Clustered Rendering Works</a></li>
<li><a href="#implementation">Implementation</a>
<ul>
<li><a href="#bin-mapping">Bin Mapping</a></li>
<li><a href="#tile-mapping">Tile Mapping</a></li>
<li><a href="#lighting-computation-in-the-shader">Lighting Computation in the Shader</a></li>
<li><a href="#code">Code</a></li>
</ul>
</li>
<li><a href="#resources">Resources</a></li>
</ul>
<h2 id="preface">Preface</h2>
<p>When doing real-time rendering for games, especially 3D games, we usually want to light the scene dynamically. Games commonly use three types of lights: Directional Lights, Point Lights, and Spot Lights.</p>
<ul>
<li>
<p>Directional Lights are ideal for simulating sunlight, providing consistent lighting across large areas.</p>
</li>
<li>
<p>Spot Lights are useful for effects like flashlights or car headlights, where the light is focused in a particular direction.</p>
</li>
<li>
<p>Point Lights simulate localized light sources such as torches, campfires, street lights, explosions, etc. They can also be strategically placed to approximate global illumination at a lower cost, since true global illumination calculations are often prohibitively expensive.</p>
</li>
</ul>
<p>To make 3D games look visually appealing, we often want to render many point lights within a scene. Unfortunately, rendering a scene with a large number of lights can be highly demanding.</p>
<p>Traditionally, scenes are rendered using a technique called Forward Rendering. This approach involves drawing model after model and, for each model, iterating through every light source to compute shading. If we have 1,000 point lights, that means every pixel being drawn must iterate over all 1,000 lights to determine the final shading. This approach can be very inefficient, especially if some pixels are later overwritten by other models (overdraw).</p>
<p>Some techniques attempt to improve efficiency, such as performing an early depth pass or using Deferred Rendering. In Deferred Rendering, shading calculations are postponed until after we determine which pixels are visible in the final image. This way, we still need to iterate over all lights for each pixel, but at least we avoid wasting computation on pixels that don’t contribute to the final picture.</p>
<p>However, even with Deferred Rendering, iterating over all 1,000 point lights per pixel is unnecessary. Most pixels are only influenced by a small subset of lights—often just one or two. This is where Clustered Rendering comes in. Clustered Rendering improves efficiency by dividing the scene into a 3D grid of clusters, allowing us to quickly determine which lights affect which parts of the scene. Importantly, Clustered Rendering works with both Forward Rendering and Deferred Rendering, making it a versatile and powerful optimization technique.</p>
<h1 id="how-clustered-rendering-works">How Clustered Rendering Works</h1>
<p>The technique I present here is adapted from the book <a href="https://www.packtpub.com/en-us/product/mastering-graphics-programming-with-vulkan-9781803244792?srsltid=AfmBOooSMOvDDKQoW3PbyByotLuH7eNUD0e_mZIE2H1RgYHncA-i-43Q">Mastering Graphics Programming with Vulkan</a>. I highly recommend this book as it provides a wealth of valuable information on advanced graphics programming. The technique was originally introduced in an <a href="https://www.activision.com/cdn/research/2017_Sig_Improved_Culling_final.pdf">Presentation from Activision about Call of Duty</a>, which also includes insights on making the algorithm more efficient. However, this blog post will focus on implementing the basic technique.</p>
<p>In this article, I&rsquo;ll explain and demonstrate the code I used in my game engine to implement Clustered Rendering within a Deferred Rendering setting. Note that there are various ways to implement Clustered Rendering—what I’ll show here is just one possible approach.</p>
<p>Clustered Forward Rendering works by dividing the camera’s view frustum (the region of space visible to the camera) into a voxel-like structure. A voxel is essentially a 3D pixel, representing a small volume in space.</p>
<p>The following picture shows the tiles. Every tile has a different color. Note, that the background/skybox isn&rsquo;t tiled. That is because it
doesn&rsquo;t get shaded in a different way.</p>
<p><img src="images/tiles.png" alt="Tiles"></p>
<p>The process can be broken down into the following steps:</p>
<ul>
<li>
<p>The frustum is divided along the depth direction (usually the Z-axis in OpenGL) into discrete sections called Bins. For example, we might divide the frustum into 16 bins.</p>
</li>
<li>
<p>The screen is further divided into a grid of Tiles, where each tile represents a block of pixels. A common choice is tiles of size 8x8 pixels.</p>
</li>
<li>
<p>Each region within the frustum can be uniquely identified by a combination of a Tile and a Bin.</p>
</li>
<li>
<p>Each point light is assigned a radius, which defines the maximum area it can influence. By comparing the position and radius of each point light to the tiles and bins, we can determine which parts of the frustum each light affects.</p>
</li>
<li>
<p>When shading a pixel, we determine which tile and bin it belongs to, then look up the point lights that influence that specific region. As a result, we only need to iterate over the relevant point lights for each pixel, significantly reducing computational overhead.</p>
</li>
</ul>
<p>The performance benefits of this approach become more apparent as the number of point lights increases. By culling irrelevant lights early, we avoid unnecessary calculations. However, there are some limitations to consider:</p>
<p>If there are only a few point lights, the overhead of assigning lights to tiles and bins may outweigh the benefits.</p>
<p>If all point lights are within a small area, little to no culling will occur, reducing the effectiveness of the technique. However, this scenario is rare in typical scenes.</p>
<p>The following screenshot marks the tiles green that are affected by a point light. Note, that tiles that are farther away than the lights radius are not affected by any point light.</p>
<p><img src="images/light_tiles.png" alt="Light Tiles"></p>
<p>In the following sections, I will walk through the code implementation of this technique and highlight important details.</p>
<h1 id="implementation">Implementation</h1>
<p>Let&rsquo;s start with the CPU-side data structures and code that make this technique work. The code snippets you&rsquo;ll see are taken directly from my engine.</p>
<p>We first need to define some constants:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">/// Maximum number of point lights that can be rendered. Could be a higher number as well.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define X_MAX_POINT_LIGHTS 1000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/// The number of Bins. The Bins divide the frustum in z direction.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define X_LIGHT_Z_BINS 16
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/// The width and height of a tile in pixels.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define X_LIGHT_TILE_SIZE 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">///
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define X_WORDS_PER_TILE_COUNT ((X_MAX_POINT_LIGHTS + 31) / 32)
</span></span></span></code></pre></div><p>Now that we’ve established our constants, the next step is to define the buffers we’ll need on the CPU side. These buffers will store data about lights, tiles, and bins, which will be passed to the GPU for rendering.</p>
<p>We&rsquo;ll use the following buffers:</p>
<ul>
<li>
<p><code>lights_ubuffer</code> — This uniform buffer stores a small amount of data, such as global constants related to lighting.</p>
</li>
<li>
<p><code>point_lights_buffer</code> — * This storage buffer holds information about all point lights in the scene, including their positions, and colors.</p>
</li>
<li>
<p><code>point_lights_lut_buffer</code> — This storage buffer is a lookup table that stores which point lights belong to which Bin.</p>
</li>
<li>
<p><code>point_lights_indices_buffer</code> — This storages buffer stores indices pointing to entries in point_lights_buffer.</p>
</li>
<li>
<p><code>point_lights_tiles_buffer</code> — This storage bufffer stores which light belongs to a given tile.</p>
</li>
</ul>
<p>You might wonder what the difference is between Uniform Buffers and Storage Buffers.</p>
<ul>
<li>
<p>Uniform Buffers: Designed for storing small amounts of data, such as constants or matrices, that need to be passed to shaders. They have strict size limits and are sometimes faster to access.</p>
</li>
<li>
<p>Storage Buffers: Designed for handling large blocks of data, such as arrays of lights. They can be read from and written to by shaders, making them more versatile but potentially slower.</p>
</li>
</ul>
<p>In theory, a Storage Buffer can replace a Uniform Buffer, but not the other way around. However, for small pieces of data, using a Uniform Buffer is often more efficient due to hardware-specific performance optimizations.</p>
<p>Lets take a look at the defintions of these buffers:</p>
<p><code>lights_ubuffer</code> looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>uniform_buffer pbr_lights
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// World space light direction of directional lights
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec4 ws_dir_light_dir[<span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Color of directional lights
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec4 dir_light_colors[<span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Number of point lights that get rendered this frame
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    uint point_light_count
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Number of directional lights in the scene
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    uint dir_light_count
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Whether IBL (Image-Based Lighting) is enabled
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    uint enable_ibl
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Some padding
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    uint pad0
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>For this example only the <code>point_light_count</code> variable is of interest.</p>
<p><code>point_lights_buffer</code> stores an array of the struct <code>point_light</code>. It contains as many <code>point_light</code> struct as <code>point_light_count</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> point_light
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vec3 position
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> radius
</span></span><span style="display:flex;"><span>    vec3 color
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> intensity
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>point_lights_lut_buffer</code> is a bit more technical. It contains an array of <code>uint</code> (unsigned integers). <code>point_lights_indices_buffer</code> contains an array of <code>uint</code> as well.</p>
<p>Last we have <code>point_lights_tiles_buffer</code> which contains an <code>uint</code> array as well.</p>
<p>Before diving into the code, let’s break down how the algorithm works on the CPU side. The process is repeated every frame to account for dynamic lighting. The steps are as follows:</p>
<ol>
<li>
<p>Sort the lights by distance from the camera. Instead of sorting the entire point light data, we only sort a list of indices referencing the point lights. This minimizes unnecessary data copying during sorting, making it more efficient.</p>
</li>
<li>
<p>Upload all point lights to the storage buffer point_lights_buffer. After sorting, the point light data is uploaded to the point_lights_buffer storage buffer for use by the GPU.</p>
</li>
<li>
<p>Compute the LUT (Look-Up Table) for the bins. The LUT allows us to efficiently map lights to bins in the shader. To build this table, we start by dividing the Z frustum into bins. For each light, we determine the minimum and maximum Z values it influences based on its position and radius. This information is then stored in the corresponding bins. Making this step efficient requires some special handling, which I’ll explain in detail later.</p>
</li>
<li>
<p>Upload the built LUT to point_lights_lut_buffer. Once the LUT is constructed, it is uploaded to the <code>point_lights_lut_buffer</code> storage buffer.</p>
</li>
<li>
<p>Assign each light to a tile. For each light, we construct an axis-aligned bounding box (AABB) based on the light’s radius. This AABB is then projected into screen coordinates to determine all the tiles influenced by the light. Efficiently storing this information also involves some special handling, which I&rsquo;ll explain later.</p>
</li>
<li>
<p>Upload the computed tile information to the storage buffer <code>point_lights_tiles_buffer</code>. The final step is to upload the tile information generated in the previous step to the <code>point_lights_tiles_buffer</code> storage buffer.</p>
</li>
</ol>
<p>On the GPU side, we use the information generated on the CPU to determine which lights contribute to the shading of each pixel. Before diving into the code, let’s first understand how the mapping from lights to bins works.</p>
<p>We have a sorted list of light indices, sorted from front to back. This allows us to store only the first and last index of the lights belonging to each bin to access all relevant light indices for that bin.</p>
<h3 id="bin-mapping">Bin Mapping</h3>
<p>For each bin, we store the first and last light index as a single 32-bit unsigned integer. This means:</p>
<ul>
<li>The upper 16 bits hold the last index.</li>
<li>The lower 16 bits hold the first index.</li>
</ul>
<p>By using this encoding, we limit the maximum number of lights to 65535. While this constraint is acceptable for most scenes, it’s worth noting that lifting this limit would double memory usage.</p>
<p>Therefore, our <code>point_lights_lut_buffer</code> contains <code>X_LIGHT_Z_BINS</code> 32-bit unsigned integers, where each entry stores the first and last index of the lights belonging to that bin.</p>
<h3 id="tile-mapping">Tile Mapping</h3>
<p>To efficiently map lights to tiles, we use a bitmask for each tile. Since each bit in the mask represents whether a particular light affects the tile, this bitmask can span multiple 32-bit unsigned integers.</p>
<p>For example, if we have 1000 lights, the number of 32-bit integers required per tile is <code>ceil(1000 / 32) == 32</code>.</p>
<h3 id="lighting-computation-in-the-shader">Lighting Computation in the Shader</h3>
<p>During lighting computation, the shader:</p>
<ol>
<li>Iterates from the first light index to the last light index of the pixel’s bin.</li>
<li>Converts each light index to a bitmask.</li>
<li>Compares the bitmask against the tile’s light bitmask.</li>
<li>If the comparison results in a value greater than zero, the light contributes to the shading.</li>
<li>If the comparison results in zero, the light can be skipped.</li>
</ol>
<h3 id="code">Code</h3>
<p>In the following, I will show the C++ code that executes on the CPU to create the bin and tile mappings for each frame.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>u32 light_count <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_u32_min</span>(render_scene.point_lights_count, X_MAX_POINT_LIGHTS);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Only execute the following code if there are lights in the scene
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (light_count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    x_sorted_light <span style="color:#f92672">*</span>sorted_lights <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">x_stack_allocn</span>(render_scene.frame_allocator, x_sorted_light, light_count);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> x_mat4 <span style="color:#f92672">&amp;</span>view_mat <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_camera_view</span>(render_scene.camera);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> x_mat4 <span style="color:#f92672">&amp;</span>proj_mat <span style="color:#f92672">=</span> render_scene.camera<span style="color:#f92672">-&gt;</span>projection;
</span></span><span style="display:flex;"><span>    f32 z_far <span style="color:#f92672">=</span> render_scene.camera<span style="color:#f92672">-&gt;</span>far_z;
</span></span><span style="display:flex;"><span>    f32 z_near <span style="color:#f92672">=</span> render_scene.camera<span style="color:#f92672">-&gt;</span>near_z;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Sort lights by distance to camera
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// To do that we project the lights z component of the lights position into view space. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// We also project each lights maximum and minimum positions z coordinate into view space.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// This information is needed later to put the lights into the correct Bins.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (u32 i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> light_count; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        x_point_light <span style="color:#f92672">*</span>light <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>render_scene.point_lights[i];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        x_vec4 p <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_vec4_init</span>(light<span style="color:#f92672">-&gt;</span>position.x, light<span style="color:#f92672">-&gt;</span>position.y, light<span style="color:#f92672">-&gt;</span>position.z, <span style="color:#ae81ff">1.0f</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        x_vec4 projected_p <span style="color:#f92672">=</span> view_mat <span style="color:#f92672">*</span> p;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// The z coordinate is negated because the camera looks in the negative z
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        projected_p.z <span style="color:#f92672">*=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1.0f</span>;
</span></span><span style="display:flex;"><span>        x_vec4 projected_p_min <span style="color:#f92672">=</span> projected_p <span style="color:#f92672">+</span> <span style="color:#a6e22e">x_vec4_init</span>(<span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>, <span style="color:#f92672">-</span>light<span style="color:#f92672">-&gt;</span>radius, <span style="color:#ae81ff">0.0f</span>);
</span></span><span style="display:flex;"><span>        x_vec4 projected_p_max <span style="color:#f92672">=</span> projected_p <span style="color:#f92672">+</span> <span style="color:#a6e22e">x_vec4_init</span>(<span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>, light<span style="color:#f92672">-&gt;</span>radius, <span style="color:#ae81ff">0.0f</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        x_sorted_light <span style="color:#f92672">*</span>sorted_light <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>sorted_lights[i];
</span></span><span style="display:flex;"><span>        sorted_light<span style="color:#f92672">-&gt;</span>light_index <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Remove negative numbers as they cause false negatives for bin 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        f32 d <span style="color:#f92672">=</span> z_far <span style="color:#f92672">-</span> z_near;
</span></span><span style="display:flex;"><span>        sorted_light<span style="color:#f92672">-&gt;</span>projected_z <span style="color:#f92672">=</span> (projected_p.z <span style="color:#f92672">-</span> z_near) <span style="color:#f92672">/</span> d;
</span></span><span style="display:flex;"><span>        sorted_light<span style="color:#f92672">-&gt;</span>projected_z_min <span style="color:#f92672">=</span> (projected_p_min.z <span style="color:#f92672">-</span> z_near) <span style="color:#f92672">/</span> d;
</span></span><span style="display:flex;"><span>        sorted_light<span style="color:#f92672">-&gt;</span>projected_z_max <span style="color:#f92672">=</span> (projected_p_max.z <span style="color:#f92672">-</span> z_near) <span style="color:#f92672">/</span> d;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Sort the lights by comparing the projected z coordinates
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">x_sort</span>(sorted_lights, light_count, <span style="color:#66d9ef">sizeof</span>(x_sorted_light), sort_lights_cmp, NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Upload point light list to GPU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x_sfx_storage_buffer_begin_frame</span>(stage<span style="color:#f92672">-&gt;</span>point_lights_buffer, render_scene.frame_allocator);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x_sfx_storage_buffer_set_data</span>(stage<span style="color:#f92672">-&gt;</span>point_lights_buffer, render_scene.point_lights,
</span></span><span style="display:flex;"><span>                                  light_count <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(x_point_light), <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x_sfx_storage_buffer_update_buffer</span>(stage<span style="color:#f92672">-&gt;</span>point_lights_buffer, cmd_buffer);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Calculate light LUT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    u32 <span style="color:#f92672">*</span>lights_lut <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_stack_allocn</span>(render_scene.frame_allocator, u32, X_LIGHT_Z_BINS);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> f32 bin_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0f</span> <span style="color:#f92672">/</span> X_LIGHT_Z_BINS;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (u32 bin <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; bin <span style="color:#f92672">&lt;</span> X_LIGHT_Z_BINS; <span style="color:#f92672">++</span>bin)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        u32 min_light_id <span style="color:#f92672">=</span> light_count <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        u32 max_light_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        f32 bin_min <span style="color:#f92672">=</span> bin <span style="color:#f92672">*</span> bin_size;
</span></span><span style="display:flex;"><span>        f32 bin_max <span style="color:#f92672">=</span> bin_min <span style="color:#f92672">+</span> bin_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Go through all lights and check if they are in the bin
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (u32 i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> light_count; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            x_sorted_light <span style="color:#f92672">*</span>sorted_light <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>sorted_lights[i];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            f32 pz_min <span style="color:#f92672">=</span> sorted_light<span style="color:#f92672">-&gt;</span>projected_z_min;
</span></span><span style="display:flex;"><span>            f32 pz_max <span style="color:#f92672">=</span> sorted_light<span style="color:#f92672">-&gt;</span>projected_z_max;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (pz_min <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.0f</span> <span style="color:#f92672">&amp;&amp;</span> pz_max <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.0f</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// The light is behind the camera, skip it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ((pz_min <span style="color:#f92672">&lt;=</span> bin_min <span style="color:#f92672">&amp;&amp;</span> pz_max <span style="color:#f92672">&gt;=</span> bin_max) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                (pz_min <span style="color:#f92672">&gt;=</span> bin_min <span style="color:#f92672">&amp;&amp;</span> pz_min <span style="color:#f92672">&lt;=</span> bin_max) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                (pz_max <span style="color:#f92672">&gt;=</span> bin_min <span style="color:#f92672">&amp;&amp;</span> pz_max <span style="color:#f92672">&lt;=</span> bin_max))
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                min_light_id <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_u32_min</span>(min_light_id, i);
</span></span><span style="display:flex;"><span>                max_light_id <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_u32_max</span>(max_light_id, i);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        lights_lut[bin] <span style="color:#f92672">=</span> min_light_id <span style="color:#f92672">|</span> (max_light_id <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">16</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Upload point light indices to GPU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">x_sfx_storage_buffer_begin_frame</span>(stage<span style="color:#f92672">-&gt;</span>point_lights_indices_buffer,
</span></span><span style="display:flex;"><span>                                     render_scene.frame_allocator);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (u32 i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> light_count; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">x_sfx_storage_buffer_set_data</span>(stage<span style="color:#f92672">-&gt;</span>point_lights_indices_buffer,
</span></span><span style="display:flex;"><span>                                      <span style="color:#f92672">&amp;</span>sorted_lights[i].light_index, <span style="color:#66d9ef">sizeof</span>(u32),
</span></span><span style="display:flex;"><span>                                      i <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(u32));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x_sfx_storage_buffer_update_buffer</span>(stage<span style="color:#f92672">-&gt;</span>point_lights_indices_buffer, cmd_buffer);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Upload point light lut to GPU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">x_sfx_storage_buffer_begin_frame</span>(stage<span style="color:#f92672">-&gt;</span>point_lights_lut_buffer,
</span></span><span style="display:flex;"><span>                                     render_scene.frame_allocator);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x_sfx_storage_buffer_set_data</span>(stage<span style="color:#f92672">-&gt;</span>point_lights_lut_buffer, lights_lut,
</span></span><span style="display:flex;"><span>                                  X_LIGHT_Z_BINS <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(u32), <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x_sfx_storage_buffer_update_buffer</span>(stage<span style="color:#f92672">-&gt;</span>point_lights_lut_buffer, cmd_buffer);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    u32 tile_x_count <span style="color:#f92672">=</span> (width <span style="color:#f92672">+</span> X_LIGHT_TILE_SIZE <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> X_LIGHT_TILE_SIZE;
</span></span><span style="display:flex;"><span>    u32 tile_y_count <span style="color:#f92672">=</span> (height <span style="color:#f92672">+</span> X_LIGHT_TILE_SIZE <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> X_LIGHT_TILE_SIZE;
</span></span><span style="display:flex;"><span>    u32 tiles_entry_count <span style="color:#f92672">=</span> tile_x_count <span style="color:#f92672">*</span> X_WORDS_PER_TILE_COUNT <span style="color:#f92672">*</span> tile_y_count;
</span></span><span style="display:flex;"><span>    u32 light_tiles_buffer_size <span style="color:#f92672">=</span> tiles_entry_count <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(u32);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Assign lights to tiles
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    u32 <span style="color:#f92672">*</span>light_tiles_bits <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">x_stack_allocn</span>(render_scene.frame_allocator, u32, light_tiles_buffer_size);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x_mem_zero</span>(light_tiles_bits, light_tiles_buffer_size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    f32 tile_size_inv <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0f</span> <span style="color:#f92672">/</span> X_LIGHT_TILE_SIZE;
</span></span><span style="display:flex;"><span>    u32 tile_stride <span style="color:#f92672">=</span> tile_x_count <span style="color:#f92672">*</span> X_WORDS_PER_TILE_COUNT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (u32 i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> light_count; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        u32 light_index <span style="color:#f92672">=</span> sorted_lights[i].light_index;
</span></span><span style="display:flex;"><span>        x_point_light <span style="color:#f92672">*</span>light <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>render_scene.point_lights[light_index];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        x_vec4 pos <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_vec4_init</span>(light<span style="color:#f92672">-&gt;</span>position.x, light<span style="color:#f92672">-&gt;</span>position.y, light<span style="color:#f92672">-&gt;</span>position.z, <span style="color:#ae81ff">1.0f</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        f32 radius <span style="color:#f92672">=</span> light<span style="color:#f92672">-&gt;</span>radius;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        x_vec4 view_space_pos <span style="color:#f92672">=</span> view_mat <span style="color:#f92672">*</span> pos;
</span></span><span style="display:flex;"><span>        f32 near_z <span style="color:#f92672">=</span> render_scene.camera<span style="color:#f92672">-&gt;</span>near_z;
</span></span><span style="display:flex;"><span>        b8 is_visible <span style="color:#f92672">=</span> view_space_pos.z <span style="color:#f92672">-</span> radius <span style="color:#f92672">&lt;</span> near_z;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>is_visible)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Build view space AABB and project it, then calculate screen AABB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        x_vec3 aabb_min <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_vec3_init</span>(F32_MAX, F32_MAX, F32_MAX);
</span></span><span style="display:flex;"><span>        x_vec3 aabb_max <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_vec3_init</span>(<span style="color:#f92672">-</span>F32_MAX, <span style="color:#f92672">-</span>F32_MAX, <span style="color:#f92672">-</span>F32_MAX);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (u32 c <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; c <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">8</span>; <span style="color:#f92672">++</span>c)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            x_vec3 corner <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">x_vec3_init</span>((c <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">1.f</span> <span style="color:#f92672">:</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1.f</span>, (c <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">1.f</span> <span style="color:#f92672">:</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1.f</span>, (c <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">1.f</span> <span style="color:#f92672">:</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1.f</span>);
</span></span><span style="display:flex;"><span>            corner <span style="color:#f92672">=</span> corner <span style="color:#f92672">*</span> radius;
</span></span><span style="display:flex;"><span>            corner <span style="color:#f92672">=</span> corner <span style="color:#f92672">+</span> <span style="color:#a6e22e">x_vec3_init</span>(pos.x, pos.y, pos.z);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Transform in view space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            x_vec4 corner_vs <span style="color:#f92672">=</span> view_mat <span style="color:#f92672">*</span> <span style="color:#a6e22e">x_vec4_init</span>(corner.x, corner.y, corner.z, <span style="color:#ae81ff">1.0f</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Adjust z on the near plane.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// Visible Z is negative, thus corner vs will be always negative, but
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// near is positive. get positive Z and invert ad the end.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            corner_vs.z <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">x_f32_max</span>(z_near, <span style="color:#f92672">-</span>corner_vs.z);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            x_vec4 corner_ndc <span style="color:#f92672">=</span> proj_mat <span style="color:#f92672">*</span> corner_vs;
</span></span><span style="display:flex;"><span>            corner_ndc <span style="color:#f92672">=</span> corner_ndc <span style="color:#f92672">/</span> corner_ndc.w;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Clamp the AABB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            aabb_min.x <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_f32_min</span>(aabb_min.x, corner_ndc.x);
</span></span><span style="display:flex;"><span>            aabb_min.y <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_f32_min</span>(aabb_min.y, corner_ndc.y);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            aabb_max.x <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_f32_max</span>(aabb_max.x, corner_ndc.x);
</span></span><span style="display:flex;"><span>            aabb_max.y <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_f32_max</span>(aabb_max.y, corner_ndc.y);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        x_vec4 aabb <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span>        aabb.x <span style="color:#f92672">=</span> aabb_min.x;
</span></span><span style="display:flex;"><span>        aabb.z <span style="color:#f92672">=</span> aabb_max.x;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Inverted Y aabb
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        aabb.w <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1.0f</span> <span style="color:#f92672">*</span> aabb_min.y;
</span></span><span style="display:flex;"><span>        aabb.y <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1.0f</span> <span style="color:#f92672">*</span> aabb_max.y;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        x_vec4 aabb_screen <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_vec4_init</span>((aabb.x <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.5f</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5f</span>) <span style="color:#f92672">*</span> (width <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>                                         (aabb.y <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.5f</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5f</span>) <span style="color:#f92672">*</span> (height <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>                                         (aabb.z <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.5f</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5f</span>) <span style="color:#f92672">*</span> (width <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>                                         (aabb.w <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.5f</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5f</span>) <span style="color:#f92672">*</span> (height <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        f32 aabb_width <span style="color:#f92672">=</span> aabb_screen.z <span style="color:#f92672">-</span> aabb_screen.x;
</span></span><span style="display:flex;"><span>        f32 aabb_height <span style="color:#f92672">=</span> aabb_screen.w <span style="color:#f92672">-</span> aabb_screen.y;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (aabb_width <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0.0001f</span> <span style="color:#f92672">||</span> aabb_height <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0.0001f</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        f32 min_x <span style="color:#f92672">=</span> aabb_screen.x;
</span></span><span style="display:flex;"><span>        f32 min_y <span style="color:#f92672">=</span> aabb_screen.y;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        f32 max_x <span style="color:#f92672">=</span> min_x <span style="color:#f92672">+</span> aabb_width;
</span></span><span style="display:flex;"><span>        f32 max_y <span style="color:#f92672">=</span> min_y <span style="color:#f92672">+</span> aabb_height;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (min_x <span style="color:#f92672">&gt;</span> width <span style="color:#f92672">||</span> min_y <span style="color:#f92672">&gt;</span> height)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (max_x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.0f</span> <span style="color:#f92672">||</span> max_y <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.0f</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        min_x <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_f32_max</span>(min_x, <span style="color:#ae81ff">0.0f</span>);
</span></span><span style="display:flex;"><span>        min_y <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_f32_max</span>(min_y, <span style="color:#ae81ff">0.0f</span>);
</span></span><span style="display:flex;"><span>        max_x <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_f32_min</span>(max_x, (f32)width);
</span></span><span style="display:flex;"><span>        max_y <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_f32_min</span>(max_y, (f32)height);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        u32 first_tile_x <span style="color:#f92672">=</span> (u32)(min_x <span style="color:#f92672">*</span> tile_size_inv);
</span></span><span style="display:flex;"><span>        u32 last_tile_x <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_u32_min</span>(tile_x_count <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, (u32)(max_x <span style="color:#f92672">*</span> tile_size_inv));
</span></span><span style="display:flex;"><span>        u32 first_tile_y <span style="color:#f92672">=</span> (u32)(min_y <span style="color:#f92672">*</span> tile_size_inv);
</span></span><span style="display:flex;"><span>        u32 last_tile_y <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_u32_min</span>(tile_y_count <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, (u32)(max_y <span style="color:#f92672">*</span> tile_size_inv));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (u32 y <span style="color:#f92672">=</span> first_tile_y; y <span style="color:#f92672">&lt;=</span> last_tile_y; <span style="color:#f92672">++</span>y)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (u32 x <span style="color:#f92672">=</span> first_tile_x; x <span style="color:#f92672">&lt;=</span> last_tile_x; <span style="color:#f92672">++</span>x)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                u32 array_index <span style="color:#f92672">=</span> y <span style="color:#f92672">*</span> tile_stride <span style="color:#f92672">+</span> (x <span style="color:#f92672">*</span> X_WORDS_PER_TILE_COUNT);
</span></span><span style="display:flex;"><span>                u32 word_index <span style="color:#f92672">=</span> i <span style="color:#f92672">/</span> <span style="color:#ae81ff">32</span>;
</span></span><span style="display:flex;"><span>                u32 bit_index <span style="color:#f92672">=</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">32</span>;
</span></span><span style="display:flex;"><span>                light_tiles_bits[array_index <span style="color:#f92672">+</span> word_index] <span style="color:#f92672">|=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> bit_index);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Upload point light tiles to GPU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">x_sfx_storage_buffer_begin_frame</span>(stage<span style="color:#f92672">-&gt;</span>point_lights_tiles_buffer,
</span></span><span style="display:flex;"><span>                                     render_scene.frame_allocator);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x_sfx_storage_buffer_set_data</span>(stage<span style="color:#f92672">-&gt;</span>point_lights_tiles_buffer, light_tiles_bits,
</span></span><span style="display:flex;"><span>                                  light_tiles_buffer_size, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x_sfx_storage_buffer_update_buffer</span>(stage<span style="color:#f92672">-&gt;</span>point_lights_tiles_buffer, cmd_buffer);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Zero out the light buffers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">x_sfx_storage_buffer_begin_frame</span>(stage<span style="color:#f92672">-&gt;</span>point_lights_lut_buffer,
</span></span><span style="display:flex;"><span>                                     render_scene.frame_allocator);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x_mem_zero</span>(stage<span style="color:#f92672">-&gt;</span>point_lights_lut_buffer<span style="color:#f92672">-&gt;</span>buffer_data,
</span></span><span style="display:flex;"><span>               stage<span style="color:#f92672">-&gt;</span>point_lights_lut_buffer<span style="color:#f92672">-&gt;</span>buffer_size);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x_sfx_storage_buffer_update_buffer</span>(stage<span style="color:#f92672">-&gt;</span>point_lights_lut_buffer, cmd_buffer);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Update lights uniform buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    x_sfx_ubuffer <span style="color:#f92672">*</span>lights_ubuffer <span style="color:#f92672">=</span> stage<span style="color:#f92672">-&gt;</span>lights_ubuffer;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x_sfx_ubuffer_begin_draw</span>(lights_ubuffer, <span style="color:#f92672">*</span>render_scene.frame_allocator);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Point lights
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    u32 point_light_count <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_u32_min</span>(X_MAX_POINT_LIGHTS, render_scene.point_lights_count);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x_sfx_ubuffer_set_uint</span>(lights_ubuffer, <span style="color:#e6db74">&#34;point_light_count&#34;</span>, <span style="color:#f92672">&amp;</span>point_light_count);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Directional lights
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    u32 dir_light_count <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">x_u32_min</span>(X_MAX_DIRECTIONAL_LIGHTS, render_scene.directional_lights_count);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dir_light_count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">x_sfx_ubuffer_set_vec4</span>(lights_ubuffer, <span style="color:#e6db74">&#34;ws_dir_light_dir&#34;</span>,
</span></span><span style="display:flex;"><span>                               render_scene.directional_light_directions, <span style="color:#ae81ff">0</span>, dir_light_count);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">x_sfx_ubuffer_set_vec4</span>(lights_ubuffer, <span style="color:#e6db74">&#34;dir_light_colors&#34;</span>,
</span></span><span style="display:flex;"><span>                               render_scene.directional_light_colors, <span style="color:#ae81ff">0</span>, dir_light_count);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x_sfx_ubuffer_set_uint</span>(lights_ubuffer, <span style="color:#e6db74">&#34;dir_light_count&#34;</span>, <span style="color:#f92672">&amp;</span>dir_light_count);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    u32 enable_ibl <span style="color:#f92672">=</span> <span style="color:#a6e22e">x_cv_graphic_ibl</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x_sfx_ubuffer_set_uint</span>(lights_ubuffer, <span style="color:#e6db74">&#34;enable_ibl&#34;</span>, <span style="color:#f92672">&amp;</span>enable_ibl);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x_sfx_ubuffer_update_buffer</span>(lights_ubuffer, cmd_buffer);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">x_sfx_material_bind</span>(<span style="color:#f92672">*</span>stage<span style="color:#f92672">-&gt;</span>lighting_material, <span style="color:#ae81ff">0</span>, cmd_buffer, <span style="color:#f92672">*</span>render_scene.frame_allocator);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">x_cmd_buffer_draw</span>(<span style="color:#f92672">&amp;</span>cmd_buffer, X_TOPOLOGY_TRIANGLE, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p><code>sort_lights_cmp</code> looks like that.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sort_lights_cmp</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>b, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#75715e">/*user_data*/</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> x_sorted_light <span style="color:#f92672">*</span>la <span style="color:#f92672">=</span> (<span style="color:#66d9ef">const</span> x_sorted_light <span style="color:#f92672">*</span>)a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> x_sorted_light <span style="color:#f92672">*</span>lb <span style="color:#f92672">=</span> (<span style="color:#66d9ef">const</span> x_sorted_light <span style="color:#f92672">*</span>)b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (la<span style="color:#f92672">-&gt;</span>projected_z <span style="color:#f92672">&lt;</span> lb<span style="color:#f92672">-&gt;</span>projected_z)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (la<span style="color:#f92672">-&gt;</span>projected_z <span style="color:#f92672">&gt;</span> lb<span style="color:#f92672">-&gt;</span>projected_z)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and <code>x_sorted_light</code> like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> x_sorted_light
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    u32 light_index;
</span></span><span style="display:flex;"><span>    f32 projected_z;
</span></span><span style="display:flex;"><span>    f32 projected_z_min;
</span></span><span style="display:flex;"><span>    f32 projected_z_max;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Next is the GLSL shader code that uses the information generated on CPU to do the light computations efficient.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GLSL" data-lang="GLSL"><span style="display:flex;"><span>pbr_params params;
</span></span><span style="display:flex;"><span>compute_pbr_params_metallic_roughness(<span style="color:#66d9ef">vec4</span>(albedo, <span style="color:#ae81ff">1.0</span>), normal, u_globals.ws_cam_pos.xyz, ws_pos, metallic, roughness, params);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">vec3</span> color <span style="color:#f92672">=</span> <span style="color:#66d9ef">vec3</span>(<span style="color:#ae81ff">0.0</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">bool</span>(u_lights.enable_ibl))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    color <span style="color:#f92672">+=</span> compute_ibl(params, params.n, params.reflection);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    color <span style="color:#f92672">+=</span> <span style="color:#66d9ef">vec3</span>(albedo <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Fetch point lights that affect this fragment</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">vec4</span> vs_pos <span style="color:#f92672">=</span> u_globals.m_view <span style="color:#f92672">*</span> <span style="color:#66d9ef">vec4</span>(ws_pos, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> z_near <span style="color:#f92672">=</span> u_globals.near_far_resx_resy.x;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> z_far <span style="color:#f92672">=</span> u_globals.near_far_resx_resy.y;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> linear_d <span style="color:#f92672">=</span> (<span style="color:#f92672">-</span>vs_pos.z <span style="color:#f92672">-</span> z_near) <span style="color:#f92672">/</span> (z_far <span style="color:#f92672">-</span> z_near);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> bin_index <span style="color:#f92672">=</span> <span style="color:#66d9ef">int</span>(linear_d <span style="color:#f92672">/</span> BIN_WIDTH);
</span></span><span style="display:flex;"><span>uint bin_value <span style="color:#f92672">=</span> u_point_lights_lut.point_lights_lut[bin_index];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uint min_light_id <span style="color:#f92672">=</span> bin_value <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffff</span>u;
</span></span><span style="display:flex;"><span>uint max_light_id <span style="color:#f92672">=</span> (bin_value <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">16</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffff</span>u;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Top left origin</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> resolution_x <span style="color:#f92672">=</span> u_globals.near_far_resx_resy.z;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> resolution_y <span style="color:#f92672">=</span> u_globals.near_far_resx_resy.w;
</span></span><span style="display:flex;"><span>uvec2 position <span style="color:#f92672">=</span> uvec2(gl_FragCoord.x <span style="color:#f92672">-</span> <span style="color:#ae81ff">0.5</span>, gl_FragCoord.y <span style="color:#f92672">-</span> <span style="color:#ae81ff">0.5</span>);
</span></span><span style="display:flex;"><span>position.y <span style="color:#f92672">=</span> uint(resolution_y) <span style="color:#f92672">-</span> position.y;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uvec2 tile <span style="color:#f92672">=</span> position <span style="color:#f92672">/</span> uint(TILE_SIZE);
</span></span><span style="display:flex;"><span>uint stride <span style="color:#f92672">=</span> uint(NUM_WORDS) <span style="color:#f92672">*</span> (uint(resolution_x <span style="color:#f92672">+</span> TILE_SIZE <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> uint(TILE_SIZE));
</span></span><span style="display:flex;"><span>uint address <span style="color:#f92672">=</span> tile.y <span style="color:#f92672">*</span> stride <span style="color:#f92672">+</span> tile.x <span style="color:#f92672">*</span> uint(NUM_WORDS);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (min_light_id <span style="color:#f92672">!=</span> u_lights.point_light_count <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Iterate over the lights that affect this fragment and compute the lighting</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (uint light_id <span style="color:#f92672">=</span> min_light_id; light_id <span style="color:#f92672">&lt;=</span> max_light_id; <span style="color:#f92672">++</span>light_id)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        uint word_id <span style="color:#f92672">=</span> light_id <span style="color:#f92672">/</span> <span style="color:#ae81ff">32</span>u;
</span></span><span style="display:flex;"><span>        uint bit_id <span style="color:#f92672">=</span> light_id <span style="color:#f92672">%</span> <span style="color:#ae81ff">32</span>u;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ((u_point_lights_tiles.point_lights_tiles[address <span style="color:#f92672">+</span> word_id] <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">1</span>u <span style="color:#f92672">&lt;&lt;</span> bit_id)) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>u)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            uint global_light_index <span style="color:#f92672">=</span> u_point_lights_indices.point_lights_indices[light_id];
</span></span><span style="display:flex;"><span>            point_light light <span style="color:#f92672">=</span> u_point_lights.point_lights[global_light_index];
</span></span><span style="display:flex;"><span>            color <span style="color:#f92672">+=</span> compute_pbr_point_light(params, ws_pos, light.position.xyz, light.color.rgb, light.radius, light.intensity);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It can be very helpful for debugging to visualize the tiles. The first GLSL code can be used in the shader to show which tiles are
affected by point lights.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GLSL" data-lang="GLSL"><span style="display:flex;"><span>uint v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NUM_WORDS; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    v <span style="color:#f92672">+=</span> bitCount(u_point_lights_tiles.point_lights_tiles[address <span style="color:#f92672">+</span> i]);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (v <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the complexity of the tile. 30 lights per tile is considered very expensive.</span>
</span></span><span style="display:flex;"><span>    color.rgb <span style="color:#f92672">+=</span> mix(<span style="color:#66d9ef">vec3</span>(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>), <span style="color:#66d9ef">vec3</span>(<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>), clamp(<span style="color:#66d9ef">float</span>(v) <span style="color:#f92672">/</span> <span style="color:#ae81ff">30.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The next GLSL code can be used to visualize all the tiles on the screen.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GLSL" data-lang="GLSL"><span style="display:flex;"><span>uint hash(uint a)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>   a <span style="color:#f92672">=</span> (a<span style="color:#f92672">+</span><span style="color:#ae81ff">0x7ed55d16</span>u) <span style="color:#f92672">+</span> (a<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">12</span>u);
</span></span><span style="display:flex;"><span>   a <span style="color:#f92672">=</span> (a<span style="color:#f92672">^</span><span style="color:#ae81ff">0xc761c23c</span>u) <span style="color:#f92672">^</span> (a<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">19</span>u);
</span></span><span style="display:flex;"><span>   a <span style="color:#f92672">=</span> (a<span style="color:#f92672">+</span><span style="color:#ae81ff">0x165667b1</span>u) <span style="color:#f92672">+</span> (a<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">5</span>u);
</span></span><span style="display:flex;"><span>   a <span style="color:#f92672">=</span> (a<span style="color:#f92672">+</span><span style="color:#ae81ff">0xd3a2646c</span>u) <span style="color:#f92672">^</span> (a<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">9</span>u);
</span></span><span style="display:flex;"><span>   a <span style="color:#f92672">=</span> (a<span style="color:#f92672">+</span><span style="color:#ae81ff">0xfd7046c5</span>u) <span style="color:#f92672">+</span> (a<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">3</span>u);
</span></span><span style="display:flex;"><span>   a <span style="color:#f92672">=</span> (a<span style="color:#f92672">^</span><span style="color:#ae81ff">0xb55a4f09</span>u) <span style="color:#f92672">^</span> (a<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">16</span>u);
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uint mhash <span style="color:#f92672">=</span> hash(address); <span style="color:#75715e">// address was defined in the GLSL listing above.</span>
</span></span><span style="display:flex;"><span>color.rgb <span style="color:#f92672">*=</span> <span style="color:#66d9ef">vec3</span>(<span style="color:#66d9ef">float</span>(mhash <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">255</span>u), <span style="color:#66d9ef">float</span>((mhash <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">8</span>u) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">255</span>u), <span style="color:#66d9ef">float</span>((mhash <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">16</span>u) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">255</span>u)) <span style="color:#f92672">/</span> <span style="color:#ae81ff">255.0</span>;
</span></span></code></pre></div><p>This concludes the implementation of my Clustered Renderer.</p>
<h2 id="resources">Resources</h2>
<p><a href="https://www.packtpub.com/en-us/product/mastering-graphics-programming-with-vulkan-9781803244792?srsltid=AfmBOooSMOvDDKQoW3PbyByotLuH7eNUD0e_mZIE2H1RgYHncA-i-43Q">Mastering Graphics Programming with Vulkan</a></p>

</article>

            </div>
        </main>
    </body></html>
